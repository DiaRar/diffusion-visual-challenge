"""
Keyframe generation and control map extraction for contest-compliant video pipeline.

All control maps must be internally generated (no external images allowed).
"""

from __future__ import annotations

import json
import logging
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

import numpy as np
from PIL import Image

if TYPE_CHECKING:
    from diffusers import StableDiffusionXLPipeline

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).parent.parent

logger = logging.getLogger(__name__)


@dataclass
class ControlMaps:
    """Container for extracted control maps from a keyframe."""

    pose: Image.Image | None = None
    depth: Image.Image | None = None
    edge: Image.Image | None = None  # Canny or LineArt


def _validate_image_shape(
    image: Image.Image, target_width: int, target_height: int
) -> Image.Image:
    """
    Validate and resize image to target dimensions.

    Args:
        image: Input PIL Image
        target_width: Target width in pixels
        target_height: Target height in pixels

    Returns:
        Resized image matching target dimensions
    """
    if image.size != (target_width, target_height):
        logger.info(
            f"Resizing image from {image.size} to ({target_width}, {target_height})"
        )
        image = image.resize((target_width, target_height), Image.Resampling.LANCZOS)
    return image


def _resize_to_latent_space(
    image: Image.Image, latent_size: int = 128
) -> Image.Image:
    """
    Resize control map to latent space dimensions (for SDXL: 128×128).

    Args:
        image: Input PIL Image
        latent_size: Latent space dimension (default 128 for SDXL)

    Returns:
        Resized image for latent space conditioning
    """
    if image.size != (latent_size, latent_size):
        logger.debug(f"Resizing control map to latent space: {latent_size}×{latent_size}")
        image = image.resize((latent_size, latent_size), Image.Resampling.LANCZOS)
    return image


def extract_control_maps(
    frame: Image.Image,
    target_width: int = 1024,
    target_height: int = 1024,
    extract_pose: bool = True,
    extract_depth: bool = True,
    extract_edge: bool = True,
) -> ControlMaps:
    """
    Extract control maps (pose, depth, edge) from an internally generated frame.

    CRITICAL: This function only works on images generated by our pipeline.
    External images are NOT allowed per contest rules.

    Args:
        frame: PIL Image (must be internally generated)
        target_width: Target width for control maps (default 1024 for SDXL)
        target_height: Target height for control maps (default 1024 for SDXL)
        extract_pose: Whether to extract OpenPose map
        extract_depth: Whether to extract depth map
        extract_edge: Whether to extract Canny/LineArt edge map

    Returns:
        ControlMaps object containing extracted maps (None if extraction disabled)

    Raises:
        ImportError: If required ControlNet preprocessors are not available
    """
    # Validate input is PIL Image
    if not isinstance(frame, Image.Image):
        raise TypeError(f"frame must be PIL.Image.Image, got {type(frame)}")

    # Resize frame to target dimensions
    frame_resized = _validate_image_shape(frame, target_width, target_height)

    maps = ControlMaps()

    # Extract OpenPose map
    if extract_pose:
        try:
            from controlnet_aux import OpenposeDetector

            pose_detector = OpenposeDetector.from_pretrained("lllyasviel/Annotators")
            pose_map = pose_detector(frame_resized)
            maps.pose = _validate_image_shape(pose_map, target_width, target_height)
            logger.info("✓ Extracted OpenPose control map")
        except ImportError:
            logger.warning(
                "controlnet_aux not available. Install with: pip install controlnet-aux"
            )
            maps.pose = None
        except Exception as e:
            logger.error(f"Failed to extract pose map: {e}")
            maps.pose = None

    # Extract depth map
    if extract_depth:
        try:
            from controlnet_aux import MidasDetector

            depth_detector = MidasDetector.from_pretrained("lllyasviel/Annotators")
            depth_map = depth_detector(frame_resized)
            maps.depth = _validate_image_shape(depth_map, target_width, target_height)
            logger.info("✓ Extracted depth control map")
        except ImportError:
            logger.warning(
                "controlnet_aux not available. Install with: pip install controlnet-aux"
            )
            maps.depth = None
        except Exception as e:
            logger.error(f"Failed to extract depth map: {e}")
            maps.depth = None

    # Extract Canny edge map
    if extract_edge:
        try:
            import cv2

            # Convert PIL to numpy for Canny
            frame_array = np.array(frame_resized.convert("RGB"))
            # Convert to grayscale
            gray = cv2.cvtColor(frame_array, cv2.COLOR_RGB2GRAY)
            # Apply Canny edge detection
            edges = cv2.Canny(gray, 100, 200)
            # Convert back to PIL Image
            edge_map = Image.fromarray(edges).convert("RGB")
            maps.edge = _validate_image_shape(edge_map, target_width, target_height)
            logger.info("✓ Extracted Canny edge control map")
        except ImportError:
            logger.warning(
                "opencv-python not available. Install with: pip install opencv-python"
            )
            maps.edge = None
        except Exception as e:
            logger.error(f"Failed to extract edge map: {e}")
            maps.edge = None

    return maps


def generate_keyframe(
    prompt: str,
    seed: int = 123,
    profile_name: str = "768_long",
    backbone: str = "sdxl",
    out_dir: Path | None = None,
    use_custom_vae: bool = False,
    **kwargs,
) -> tuple[Image.Image, Path]:
    """
    Generate a single keyframe image (internally generated, contest-compliant).

    This is a wrapper around generate_single_image that ensures the output
    is saved and returned as a PIL Image for control map extraction.

    Args:
        prompt: Text prompt for generation
        seed: Random seed for reproducibility
        profile_name: Profile name (e.g., "768_long", "1024_hq")
        backbone: Model backbone (only "sdxl" supported)
        out_dir: Output directory (default: outputs/keyframes/)
        use_custom_vae: Whether to use custom VAE
        **kwargs: Additional arguments passed to generate_single_image

    Returns:
        Tuple of (PIL Image, output file path)

    Raises:
        ValueError: If prompt is empty or backbone is invalid
    """
    # Import generate_single_image from the same package
    # Note: PROJECT_ROOT is already in sys.path from generate_image.py
    from infer.generate_image import generate_single_image

    # Set default output directory
    if out_dir is None:
        out_dir = PROJECT_ROOT / "outputs" / "keyframes"
    out_dir.mkdir(parents=True, exist_ok=True)

    # Generate unique filename
    import hashlib
    from datetime import datetime

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    prompt_hash = hashlib.md5(prompt.encode()).hexdigest()[:8]
    filename = f"keyframe_{timestamp}_{seed}_{prompt_hash}.png"
    out_path = out_dir / filename

    # Generate image
    logger.info(f"Generating keyframe: {prompt[:50]}...")
    generated_path = generate_single_image(
        prompt=prompt,
        backbone=backbone,
        profile_name=profile_name,
        seed=seed,
        out_path=str(out_path),
        use_custom_vae=use_custom_vae,
        **kwargs,
    )

    # Load and return as PIL Image
    keyframe_image = Image.open(generated_path)
    logger.info(f"✓ Keyframe saved to: {generated_path}")

    return keyframe_image, generated_path


def save_control_maps(
    maps: ControlMaps,
    keyframe_path: Path,
    output_dir: Path | None = None,
) -> dict[str, Path]:
    """
    Save control maps to disk with structured naming.

    Args:
        maps: ControlMaps object containing extracted maps
        keyframe_path: Path to the source keyframe image
        output_dir: Output directory (default: outputs/controlmaps/)

    Returns:
        Dictionary mapping map type to saved file path
    """
    if output_dir is None:
        output_dir = PROJECT_ROOT / "outputs" / "controlmaps"
    output_dir.mkdir(parents=True, exist_ok=True)

    # Extract keyframe basename (without extension)
    keyframe_stem = keyframe_path.stem

    saved_paths: dict[str, Path] = {}

    if maps.pose is not None:
        pose_path = output_dir / f"{keyframe_stem}_pose.png"
        maps.pose.save(pose_path)
        saved_paths["pose"] = pose_path
        logger.info(f"✓ Saved pose map: {pose_path}")

    if maps.depth is not None:
        depth_path = output_dir / f"{keyframe_stem}_depth.png"
        maps.depth.save(depth_path)
        saved_paths["depth"] = depth_path
        logger.info(f"✓ Saved depth map: {depth_path}")

    if maps.edge is not None:
        edge_path = output_dir / f"{keyframe_stem}_edge.png"
        maps.edge.save(edge_path)
        saved_paths["edge"] = edge_path
        logger.info(f"✓ Saved edge map: {edge_path}")

    return saved_paths


def update_controlmap_registry(
    keyframe_path: Path,
    control_map_paths: dict[str, Path],
    registry_path: Path | None = None,
) -> None:
    """
    Update JSON registry of control maps for reproducibility.

    Args:
        keyframe_path: Path to the keyframe image
        control_map_paths: Dictionary mapping map type to saved file path
        registry_path: Path to registry JSON (default: outputs/controlmaps/index.json)
    """
    if registry_path is None:
        registry_path = PROJECT_ROOT / "outputs" / "controlmaps" / "index.json"

    # Load existing registry or create new
    if registry_path.exists():
        with open(registry_path) as f:
            registry = json.load(f)
    else:
        registry = {}

    # Add entry for this keyframe
    keyframe_stem = keyframe_path.stem
    registry[keyframe_stem] = {
        "keyframe": str(keyframe_path.relative_to(PROJECT_ROOT)),
        "control_maps": {
            map_type: str(path.relative_to(PROJECT_ROOT))
            for map_type, path in control_map_paths.items()
        },
    }

    # Save updated registry
    registry_path.parent.mkdir(parents=True, exist_ok=True)
    with open(registry_path, "w") as f:
        json.dump(registry, f, indent=2)

    logger.info(f"✓ Updated control map registry: {registry_path}")


def generate_keyframe_with_maps(
    prompt: str,
    seed: int = 123,
    profile_name: str = "768_long",
    extract_pose: bool = True,
    extract_depth: bool = True,
    extract_edge: bool = True,
    use_custom_vae: bool = False,
    **kwargs,
) -> tuple[Image.Image, ControlMaps, dict[str, Path]]:
    """
    Generate a keyframe and extract all control maps in one call.

    This is the main convenience function for Day 2 pipeline.

    Args:
        prompt: Text prompt for generation
        seed: Random seed for reproducibility
        profile_name: Profile name
        extract_pose: Whether to extract pose map
        extract_depth: Whether to extract depth map
        extract_edge: Whether to extract edge map
        use_custom_vae: Whether to use custom VAE
        **kwargs: Additional arguments for generate_keyframe

    Returns:
        Tuple of (keyframe Image, ControlMaps object, saved map paths dict)
    """
    # Generate keyframe
    keyframe_image, keyframe_path = generate_keyframe(
        prompt=prompt,
        seed=seed,
        profile_name=profile_name,
        use_custom_vae=use_custom_vae,
        **kwargs,
    )

    # Get profile dimensions for control map extraction
    from configs.profiles import get_profile

    profile = get_profile(profile_name)

    # Extract control maps
    maps = extract_control_maps(
        keyframe_image,
        target_width=profile.width,
        target_height=profile.height,
        extract_pose=extract_pose,
        extract_depth=extract_depth,
        extract_edge=extract_edge,
    )

    # Save maps
    saved_paths = save_control_maps(maps, keyframe_path)

    # Update registry
    if saved_paths:
        update_controlmap_registry(keyframe_path, saved_paths)

    return keyframe_image, maps, saved_paths

